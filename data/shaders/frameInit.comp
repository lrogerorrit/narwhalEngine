#version 460

// Constants

const float PI = 3.1415926535897932384626433832795028841971693993751058209749;
const int xSize= 8;
const int ySize= 8;

layout(local_size_x = xSize, local_size_y = ySize, local_size_z = 1) in;

layout(binding=0) uniform parameters{
    ivec2 windowSize;
    mat4x4 camToWorld;
    mat4x4 camInverseProj;
    vec3 camPosCartesian;
    vec3 camPosSpherical;
    float horizonRadius;
} initParams;
layout(binding=1,rgba8) uniform image2D colorOutput;
layout(binding=2,rgba8) uniform image2D  posOutput;
layout(binding=3,rgba8) uniform image2D  dirOutput;
layout(binding = 4, r8ui) uniform uimage2D isComplete;




// Cartesian to spherical coordinate conversion
vec3 ToSphericalScalar(vec3 cart)
{
    float r = length(cart);
    float rxz = length(cart.xz);
    float theta = atan(rxz, cart.y);
    float phi = atan(cart.z, cart.x);

    return vec3(r, theta, phi);
}

// Cartesian to Spherical vector conversion (inputs in cartesian)
vec3 ToSphericalVector(vec3 origin, vec3 dir)
{
	float r= length(origin);
	float rxz= length(origin.xz);
	mat3x3 L = mat3x3(
        origin.x / r,                        // dr/dx
        origin.y / r,                        // dr/dy
        origin.z / r,                        // dr/dz
        origin.x * origin.y / (r * r * rxz), // dtheta/dx
        -rxz / (r * r),                      // dtheta/dy
        origin.z* origin.y / (r * r * rxz),  // dtheta/dz
        -origin.z / rxz,                     // dphi/dx
        0.0,                                 // dphi/dy
        origin.x / rxz                       // dphi/dz
    );
     return dir*L;
}



// Spherical to Cartesian coordinate conversion
vec3 ToCartesianScalar(vec3 sph)
{
    float x = sph.x * cos(sph.z) * sin(sph.y);
    float y = sph.x * cos(sph.y);
    float z = sph.x * sin(sph.z) * sin(sph.y);

    return vec3(x, y, z);
}

// Spherical to Cartesian vector conversion (inputs in spherical)
vec3 ToCartesianVector(vec3 origin, vec3 dir)
{
    mat3x3 L = mat3x3(
        sin(origin.y) * cos(origin.z),              // dx/dr
        origin.x * cos(origin.y) * cos(origin.z),   // dx/dtheta
        -origin.x * sin(origin.y) * sin(origin.z),  // dx/dphi
        cos(origin.y),                              // dz/dr
        -origin.x * sin(origin.y),                  // dz/dtheta
        0.0,                                        // dz/dphi
        sin(origin.y) * sin(origin.z),              // dy/dr
        origin.x* cos(origin.y)* sin(origin.z),     // dy/dtheta
        origin.x* sin(origin.y)* cos(origin.z)      // dy/dphi
    );

    return dir*L;
}

vec3 cartesian_to_spherical(vec3 origin, vec3 dir) {
  vec3 v = dir - origin;
  float r = length(v);
  float theta = acos(v.z / r);
  float phi = atan(v.y, v.x);
  return vec3(r, theta, phi);
}


bool checkWindowBound(ivec2 pos)
{
	return (pos.x >= 0 && pos.x < initParams.windowSize.x && pos.y >= 0 && pos.y < initParams.windowSize.y);
}

// linear to srgb
vec3 gamma(vec3 c)
{
	return pow(c,vec3(1.0/2.2));
}
//SRGB to linear
vec3 degamma(vec3 c)
{
	return pow(c,vec3(2.2));
}



void main(){
    ivec2 id= ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y);
    

    if (!checkWindowBound(id.xy))
	{
		return;
	}

    uint width,height;
    width= initParams.windowSize.x;
    height= initParams.windowSize.y;
    vec2 screenSize=imageSize(colorOutput);
    float _width= screenSize.x;
    float _height= screenSize.y;

    //Transform pixel to [-1,1] range
     vec2 uv= vec2(id.x/_width, id.y/_height);
     uv= uv*2.0-1.0;
    
    //We now get the screen position
    vec4 screenPos= vec4(uv.xy,0.0,1.0);
    vec4 projWorldPos= screenPos*initParams.camInverseProj;
    

    //We now get the world_position;
    vec3 worldPos= projWorldPos.xyz/projWorldPos.w;

    vec3 direction= (vec4(worldPos.xyz,0)* initParams.camToWorld).xyz;

    direction= normalize(direction);

    vec3 originSph= initParams.camPosSpherical;
    vec3 directionSph= ToSphericalVector(initParams.camPosCartesian,direction);

    //We now lower the indices of velocity
    directionSph.x*= (1.0- (initParams.horizonRadius/originSph.x));
    directionSph.y*= originSph.x*originSph.x;
    directionSph.z*= originSph.x*sin(originSph.y);


    imageStore(posOutput,id,vec4(originSph,0.0));
    //imageStore(dirOutput,id,vec4(direction,0.0));
    imageStore(dirOutput,id,vec4((directionSph),0.0));
    imageStore(colorOutput,id,vec4(0.0,0.0,0.0,0.0));
    imageStore(isComplete,id,ivec4(0,0,0,0));
}